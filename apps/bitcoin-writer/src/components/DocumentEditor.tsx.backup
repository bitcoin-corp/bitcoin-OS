import React, { useState, useEffect, useRef, useCallback } from 'react';
import { BlockchainDocumentService, DocumentData, BlockchainDocument } from '../services/BlockchainDocumentService';
import PricingDisplay from './PricingDisplay';
import PublishSettingsModal, { PublishSettings } from './PublishSettingsModal';
import EnhancedStorageModal, { StorageOptions } from './EnhancedStorageModal';
import TokenizeModal, { TokenizationOptions } from './TokenizeModal';
import PostToTwitterModal from './PostToTwitterModal';
import { StorageOption } from '../utils/pricingCalculator';

interface DocumentEditorProps {
  documentService: BlockchainDocumentService | null;
  isAuthenticated: boolean;
  onAuthRequired: () => void;
  currentDocument?: BlockchainDocument | null;
  onDocumentUpdate?: (doc: BlockchainDocument) => void;
}

const DocumentEditor: React.FC<DocumentEditorProps> = ({ 
  documentService, 
  isAuthenticated, 
  onAuthRequired,
  currentDocument: propDocument,
  onDocumentUpdate 
}) => {
  const [currentDocument, setCurrentDocument] = useState<DocumentData | null>(null);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [wordCount, setWordCount] = useState(0);
  const [charCount, setCharCount] = useState(0);
  const [cursorPosition, setCursorPosition] = useState('Line 1, Column 1');
  const [autoSaveStatus, setAutoSaveStatus] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [selectedStorageOption, setSelectedStorageOption] = useState<StorageOption | null>(null);
  const [editorContent, setEditorContent] = useState('');
  const [showPublishModal, setShowPublishModal] = useState(false);
  const [publishSettings, setPublishSettings] = useState<PublishSettings | null>(null);
  const [isEncrypted, setIsEncrypted] = useState(false);
  const [readPrice, setReadPrice] = useState<number>(0);
  const [showStorageModal, setShowStorageModal] = useState(false);
  const [, setStorageOptions] = useState<StorageOptions | null>(null);
  const [showActionsDropdown, setShowActionsDropdown] = useState(false);
  const [showTokenizeModal, setShowTokenizeModal] = useState(false);
  const [showTwitterModal, setShowTwitterModal] = useState(false);

  const editorRef = useRef<HTMLDivElement>(null);
  const imageInputRef = useRef<HTMLInputElement>(null);

  // Load document when propDocument changes
  useEffect(() => {
    if (propDocument) {
      // Load the selected document
      setCurrentDocument({
        id: propDocument.id,
        title: propDocument.title,
        content: propDocument.content || '',
        metadata: {
          created_at: propDocument.created_at,
          updated_at: propDocument.updated_at,
          author: propDocument.author || '',
          encrypted: propDocument.encrypted || false,
          word_count: propDocument.word_count || 0,
          character_count: propDocument.character_count || 0,
          storage_method: propDocument.storage_method,
          blockchain_tx: propDocument.blockchain_tx,
          storage_cost: propDocument.storage_cost
        }
      });
      setEditorContent(propDocument.content || '');
      if (editorRef.current) {
        editorRef.current.textContent = propDocument.content || '';
      }
    } else if (!isAuthenticated) {
      // Load from localStorage for guest users
      loadLocalDocument();
    } else {
      // Clear editor for new document
      setCurrentDocument(null);
      setEditorContent('');
      if (editorRef.current) {
        editorRef.current.textContent = '';
      }
    }

  // Listen for tokenize modal event
  useEffect(() => {
    const handleOpenTokenizeModal = () => {
      setShowTokenizeModal(true);
    };

    window.addEventListener('openTokenizeModal', handleOpenTokenizeModal);
    
    return () => {
      window.removeEventListener('openTokenizeModal', handleOpenTokenizeModal);
    };
  }, []);

  // Listen for Twitter modal event
  useEffect(() => {
    const handleOpenTwitterModal = () => {
      setShowTwitterModal(true);
    };

    window.addEventListener('openTwitterModal', handleOpenTwitterModal);
    
    return () => {
      window.removeEventListener('openTwitterModal', handleOpenTwitterModal);
    };
  }, []);


  const loadLocalDocument = useCallback(() => {
    // Load any auto-saved content from localStorage
    const savedContent = localStorage.getItem('bitcoinWriter_localContent');
    if (savedContent && editorRef.current) {
      editorRef.current.innerHTML = savedContent;
      updateCounts();
    }
  }, [updateCounts]);

  // Handle document changes (load local or clear editor)
  useEffect(() => {
    if (propDocument) {
      // Load existing document
      setCurrentDocument(propDocument);
      setEditorContent(propDocument.content);
      if (editorRef.current) {
        editorRef.current.innerHTML = propDocument.content;
      }
      updateCounts();
    } else if (!isAuthenticated) {
      // Load from localStorage for guest users
      loadLocalDocument();
    } else {
      // Clear editor for new document
      setCurrentDocument(null);
      setEditorContent('');
      if (editorRef.current) {
        editorRef.current.textContent = '';
      }
    }
  }, [propDocument, isAuthenticated, loadLocalDocument]);

  const saveToLocalStorage = () => {
    if (editorRef.current) {
      const content = editorRef.current.innerHTML;
      localStorage.setItem('bitcoinWriter_localContent', content);
      localStorage.setItem('bitcoinWriter_lastSaved', Date.now().toString());
    }
  };

  const updateCounts = useCallback(() => {
    if (!editorRef.current) return;

    const text = editorRef.current.textContent || '';
    const html = editorRef.current.innerHTML || '';
    const isPlaceholder = text.trim() === 'Start writing...';
    
    if (isPlaceholder) {
      setWordCount(0);
      setCharCount(0);
      setEditorContent('');
      return;
    }

    const words = text.trim() ? text.trim().split(/\s+/).length : 0;
    const chars = text.length;

    setWordCount(words);
    setCharCount(chars);
    setEditorContent(html);
  }, []);

  const updateCursorPosition = useCallback(() => {
    const selection = window.getSelection();
    if (selection && selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const preCaretRange = range.cloneRange();
      preCaretRange.selectNodeContents(editorRef.current!);
      preCaretRange.setEnd(range.endContainer, range.endOffset);
      
      const text = preCaretRange.toString();
      const lines = text.split('\n');
      const line = lines.length;
      const column = lines[lines.length - 1].length + 1;
      
      setCursorPosition(`Line ${line}, Column ${column}`);
    }
  }, []);

  const hasUnsavedChanges = useCallback((): boolean => {
    if (!editorRef.current || !currentDocument) return false;
    const currentContent = editorRef.current.innerHTML;
    return currentContent !== currentDocument.content;
  }, [currentDocument]);

  const newDocument = async () => {
    if (hasUnsavedChanges()) {
      if (!window.confirm('You have unsaved changes. Are you sure you want to create a new document?')) {
        return;
      }
    }

    // For guest users, just clear the editor
    if (!isAuthenticated) {
      if (editorRef.current) {
        editorRef.current.innerHTML = '<p>Start writing...</p>';
        editorRef.current.focus();
        localStorage.removeItem('bitcoinWriter_localContent');
        updateCounts();
      }
      return;
    }

    // For authenticated users, also just clear the editor
    // Document will be created on blockchain when user saves
    setCurrentDocument(null);
    setEditorContent('');
    if (editorRef.current) {
      editorRef.current.innerHTML = '';
      editorRef.current.focus();
    }
    localStorage.removeItem('bitcoinWriter_localContent');
    updateCounts();
    showNotification('Ready for new document')
  };


  const saveDocument = async () => {
    // If not authenticated, prompt to sign in
    if (!isAuthenticated) {
      const shouldSignIn = window.confirm(
        'To save your document on the blockchain, you need to sign in with HandCash.\n\n' +
        'Your document will be encrypted and permanently stored on Bitcoin SV.\n\n' +
        'Would you like to sign in now?'
      );
      
      if (shouldSignIn) {
        // Save to local storage first so content isn't lost
        saveToLocalStorage();
        onAuthRequired();
      } else {
        // Just save locally
        saveToLocalStorage();
        showNotification('Document saved locally (not on blockchain)');
      }
      return;
    }

    // Show enhanced storage modal for blockchain save
    setShowStorageModal(true);
  };

  const handleStorageSave = async (options: StorageOptions) => {
    if (!documentService || !editorRef.current) return;

    try {
      setIsLoading(true);
      setShowStorageModal(false);
      setStorageOptions(options);
      setAutoSaveStatus('üíæ Saving to blockchain...');
      
      const content = editorRef.current.innerHTML;
      const title = extractTitleFromContent(content) || 'Untitled Document';
      
      // If no current document, create a new one
      if (!currentDocument) {
        const doc = await documentService.createDocument(title, content, options.method);
        setCurrentDocument(doc);
        // Notify parent component about the new document
        if (onDocumentUpdate) {
          onDocumentUpdate({
            id: doc.id,
            title: doc.title,
            content: doc.content || '',
            preview: doc.content?.substring(0, 100) || '',
            created_at: doc.metadata.created_at,
            updated_at: doc.metadata.updated_at,
            author: doc.metadata.author,
            encrypted: doc.metadata.encrypted,
            word_count: doc.metadata.word_count,
            character_count: doc.metadata.character_count,
            storage_method: doc.metadata.storage_method,
            blockchain_tx: doc.metadata.blockchain_tx,
            storage_cost: doc.metadata.storage_cost
          });
        }
      } else {
        await documentService.updateDocument(currentDocument.id, title, content, options.method);
        setCurrentDocument(prev => prev ? {
          ...prev,
          title,
          content,
          lastUpdated: Date.now(),
          wordCount,
          charCount
        } : null);
      }
      
      // Show appropriate success message based on storage method
      let successMessage = 'Document saved to blockchain';
      if (options.method === 'nft_creation') {
        successMessage = 'NFT minted successfully!';
      } else if (options.method === 'file_shares') {
        successMessage = 'File shares issued successfully!';
      }
      
      setAutoSaveStatus('‚úÖ Saved to blockchain');
      setTimeout(() => setAutoSaveStatus(''), 2000);
      showNotification(successMessage);
      
      // Clear local storage after successful blockchain save
      localStorage.removeItem('bitcoinWriter_localContent');
    } catch (error) {
      console.error('Failed to save document:', error);
      setAutoSaveStatus('‚ùå Blockchain save failed');
      setTimeout(() => setAutoSaveStatus(''), 3000);
      showNotification('Failed to save to blockchain', 'error');
    } finally {
      setIsLoading(false);
    }
  };

  const handleTokenize = async (protocol: string, options: TokenizationOptions) => {
    try {
      setIsLoading(true);
      console.log('Tokenizing document with protocol:', protocol, options);
      
      // TODO: Implement actual tokenization logic here
      // This would involve:
      // 1. Connecting to the selected BSV protocol
      // 2. Creating the token with specified parameters
      // 3. Minting the token on-chain
      // 4. Storing token metadata
      
      alert(`Document would be tokenized using ${options.name} on ${protocol.toUpperCase()} protocol.\n\nThis feature is coming soon!`);
      
    } catch (error) {
      console.error('Failed to tokenize document:', error);
      alert('Failed to tokenize document: ' + (error instanceof Error ? error.message : 'Unknown error'));
    } finally {
      setIsLoading(false);
    }
  };

  const autoSave = useCallback(async () => {
    if (!editorRef.current) return;

    // For guest users, just save to local storage
    if (!isAuthenticated) {
      saveToLocalStorage();
      setAutoSaveStatus('‚úÖ Auto-saved locally');
      setTimeout(() => setAutoSaveStatus(''), 2000);
      return;
    }

    // For authenticated users with a document on blockchain
    if (!currentDocument || !documentService) return;

    try {
      setAutoSaveStatus('üíæ Auto-saving to blockchain...');

      const content = editorRef.current.innerHTML;
      const title = extractTitleFromContent(content) || currentDocument.title;

      await documentService.updateDocument(currentDocument.id, title, content, selectedStorageOption?.id as any);

      setCurrentDocument(prev => prev ? {
        ...prev,
        title,
        content,
        lastUpdated: Date.now(),
        wordCount,
        charCount
      } : null);

      setAutoSaveStatus('‚úÖ Auto-saved to blockchain');
      setTimeout(() => setAutoSaveStatus(''), 2000);
    } catch (error) {
      console.error('Auto-save failed:', error);
      setAutoSaveStatus('‚ùå Auto-save failed');
      setTimeout(() => setAutoSaveStatus(''), 3000);
    }
  }, [isAuthenticated, currentDocument, documentService, selectedStorageOption, wordCount, charCount]);

  // Auto-save interval
  useEffect(() => {
    const interval = setInterval(() => {
      if (currentDocument && hasUnsavedChanges()) {
        autoSave();
      }
    }, 30000); // Auto-save every 30 seconds

    return () => clearInterval(interval);
  }, [currentDocument, autoSave, hasUnsavedChanges]);

  const extractTitleFromContent = (html: string): string => {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    const text = tempDiv.textContent || tempDiv.innerText || '';
    const firstLine = text.split('\n')[0].trim();
    return firstLine.length > 0 && firstLine.length <= 100 ? firstLine : 'Untitled Document';
  };

  const insertImage = () => {
    imageInputRef.current?.click();
  };

  const handleImageSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        if (event.target?.result) {
          insertImageIntoEditor(event.target.result as string, file.name);
        }
      };
      reader.readAsDataURL(file);
    }
  };

  const insertImageIntoEditor = (imageSrc: string, fileName: string) => {
    if (!editorRef.current) return;

    const img = document.createElement('img');
    img.src = imageSrc;
    img.alt = fileName;
    img.style.maxWidth = '100%';
    img.style.height = 'auto';
    img.style.margin = '10px 0';
    img.style.borderRadius = '4px';

    const selection = window.getSelection();
    if (selection && selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      range.insertNode(img);
      range.setStartAfter(img);
      range.setEndAfter(img);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    updateCounts();
    editorRef.current.focus();
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    // Keyboard shortcuts
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
      e.preventDefault();
      saveDocument();
    } else if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
      e.preventDefault();
      newDocument();
    } else if (e.key === 'F11') {
      e.preventDefault();
      toggleFullscreen();
    } else if (e.key === 'Tab') {
      e.preventDefault();
      document.execCommand('insertText', false, '    ');
    }
  };

  const toggleFullscreen = () => {
    setIsFullscreen(!isFullscreen);
  };

  const handlePaste = (e: React.ClipboardEvent) => {
    e.preventDefault();
    const text = e.clipboardData.getData('text/plain');
    document.execCommand('insertText', false, text);
  };

  const showNotification = (message: string, type: 'success' | 'error' = 'success') => {
    // Simple notification implementation
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: ${type === 'error' ? '#ff4444' : '#44ff44'};
      color: white;
      padding: 12px 20px;
      border-radius: 6px;
      z-index: 10000;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transition: opacity 0.3s ease;
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
      notification.style.opacity = '0';
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }, 3000);
  };

  const handleEncrypt = () => {
    if (isEncrypted) {
      // Decrypt
      setIsEncrypted(false);
      showNotification('Document decrypted');
    } else {
      // Encrypt
      setIsEncrypted(true);
      showNotification('Document encrypted');
    }
  };

  const handleSetPrice = () => {
    const price = prompt('Set price to read (in USD):', readPrice.toString());
    if (price !== null && !isNaN(Number(price))) {
      setReadPrice(Number(price));
      showNotification(`Read price set to $${price}`);
    }
  };

  return (
    <div className={`document-editor ${isFullscreen ? 'fullscreen' : ''}`}>
      <div className="toolbar">
        {/* Mobile Layout */}
        <div className="toolbar-mobile">
          <div className="mobile-main-actions">
            <button 
              onClick={saveDocument} 
              disabled={isLoading} 
              title={isAuthenticated ? "Save to Blockchain" : "Save (Sign in for blockchain)"}
              className={`save-btn-mobile ${!isAuthenticated ? 'save-guest' : ''}`}
            >
              üíæ {isAuthenticated ? 'Save' : 'Save'}
            </button>
            
            <div className="mobile-dropdown-container">
              <button 
                className="mobile-actions-btn"
                onClick={() => setShowActionsDropdown(!showActionsDropdown)}
                title="More actions"
              >
                ‚öôÔ∏è Actions
              </button>
              
              {showActionsDropdown && (
                <div className="mobile-dropdown">
                  <button 
                    onClick={() => {
                      insertImage();
                      setShowActionsDropdown(false);
                    }}
                    className="dropdown-item"
                  >
                    üì∑ Add Image
                  </button>
                  {isAuthenticated && (
                    <>
                      <button 
                        onClick={() => {
                          handleEncrypt();
                          setShowActionsDropdown(false);
                        }}
                        disabled={isLoading}
                        className={`dropdown-item ${isEncrypted ? 'encrypted' : ''}`}
                      >
                        {isEncrypted ? 'üîì Decrypt' : 'üîí Encrypt Draft'}
                      </button>
                      <button 
                        onClick={() => {
                          handleSetPrice();
                          setShowActionsDropdown(false);
                        }}
                        disabled={isLoading}
                        className="dropdown-item"
                      >
                        üí∞ Set Price to Read {readPrice > 0 ? `($${readPrice})` : ''}
                      </button>
                      <button 
                        onClick={() => {
                          setShowPublishModal(true);
                          setShowActionsDropdown(false);
                        }}
                        disabled={isLoading}
                        className="dropdown-item"
                      >
                        üåç Publish Document
                      </button>
                    </>
                  )}
                  <button 
                    onClick={() => {
                      toggleFullscreen();
                      setShowActionsDropdown(false);
                    }}
                    className="dropdown-item"
                  >
                    ‚õ∂ Fullscreen
                  </button>
                </div>
              )}
            </div>
          </div>
          
          <div className="mobile-stats">
            <span className="word-count">{wordCount}w</span>
            <span className="char-count">{charCount}c</span>
            <PricingDisplay 
              wordCount={wordCount}
              characterCount={charCount}
              content={editorContent}
              isAuthenticated={isAuthenticated}
              onStorageMethodSelect={setSelectedStorageOption}
              isMobile={true}
            />
          </div>
        </div>

        {/* Desktop Layout */}
        <div className="toolbar-desktop">
          <div className="toolbar-left">
            <button 
              onClick={saveDocument} 
              disabled={isLoading} 
              title={isAuthenticated ? "Save encrypted draft to blockchain" : "Save (Sign in for blockchain)"}
              className={!isAuthenticated ? 'save-guest' : ''}
            >
              üíæ {isAuthenticated ? 'Save to Blockchain' : 'Save'}
            </button>
            
            <button onClick={insertImage} title="Add images to your document (included in blockchain storage cost)">
              üì∑ Add Image
            </button>
            
            {isAuthenticated && (
              <>
                <button 
                  onClick={handleEncrypt}
                  disabled={isLoading}
                  title={isEncrypted ? "Make document readable to you only" : "Encrypt draft for privacy"}
                  className={`encrypt-btn ${isEncrypted ? 'encrypted' : ''}`}
                >
                  {isEncrypted ? 'üîì Decrypt Draft' : 'üîí Encrypt Draft'}
                </button>
                <button 
                  onClick={handleSetPrice}
                  disabled={isLoading}
                  title="Set price readers must pay to read your document"
                  className="price-btn"
                >
                  üí∞ Set Price to Read {readPrice > 0 ? `($${readPrice})` : ''}
                </button>
                <button 
                  onClick={() => setShowPublishModal(true)}
                  disabled={isLoading}
                  title="Make document publicly accessible (optionally behind paywall)"
                  className="publish-btn"
                >
                  üåç Publish Document
                </button>
                <button 
                  onClick={() => setShowTwitterModal(true)}
                  disabled={isLoading}
                  title="Share your writing on Twitter"
                  className="twitter-share-btn"
                >
                  üê¶ Post to Twitter
                </button>
              </>
            )}
            <input
              type="file"
              ref={imageInputRef}
              accept="image/*"
              style={{ display: 'none' }}
              onChange={handleImageSelect}
            />
          </div>
          
          <div className="toolbar-center">
            <span>{wordCount} word{wordCount !== 1 ? 's' : ''}</span>
            <span>{charCount} character{charCount !== 1 ? 's' : ''}</span>
            <PricingDisplay 
              wordCount={wordCount}
              characterCount={charCount}
              content={editorContent}
              isAuthenticated={isAuthenticated}
              onStorageMethodSelect={setSelectedStorageOption}
            />
          </div>
          
          <div className="toolbar-right">
            <button onClick={toggleFullscreen} title="Toggle Fullscreen">
              ‚õ∂
            </button>
          </div>
        </div>
      </div>

      <div className="editor-container">
        <div
          ref={editorRef}
          className="editor"
          contentEditable
          spellCheck
          onInput={updateCounts}
          onKeyUp={updateCursorPosition}
          onClick={updateCursorPosition}
          onKeyDown={handleKeyDown}
          onPaste={handlePaste}
          suppressContentEditableWarning
        >
          <p>Start writing...</p>
        </div>
      </div>

      <div className="status-bar">
        <span>{cursorPosition}</span>
        <span className="auto-save-status">{autoSaveStatus}</span>
        <span>{currentDocument?.title || 'Untitled'}</span>
      </div>

      
      <PublishSettingsModal
        isOpen={showPublishModal}
        onClose={() => setShowPublishModal(false)}
        onConfirm={(settings) => {
          setPublishSettings(settings);
          // TODO: Save publish settings with document
          console.log('Publish settings:', settings);
        }}
        currentSettings={publishSettings || undefined}
        documentTitle={currentDocument?.title || 'Untitled'}
      />

      <EnhancedStorageModal
        isOpen={showStorageModal}
        onClose={() => setShowStorageModal(false)}
        onSave={handleStorageSave}
        documentTitle={currentDocument?.title || 'Untitled Document'}
        estimatedSize={charCount}
      />

      <TokenizeModal
        isOpen={showTokenizeModal}
        onClose={() => setShowTokenizeModal(false)}
        onTokenize={handleTokenize}
        documentTitle={currentDocument?.title || 'Untitled Document'}
        wordCount={wordCount}
      />

      <PostToTwitterModal
        isOpen={showTwitterModal}
        onClose={() => setShowTwitterModal(false)}
        documentTitle={currentDocument?.title || 'Untitled Document'}
        documentContent={editorRef.current?.innerHTML || ''}
      />
      
      {isLoading && (
        <div className="loading-overlay">
          <div className="spinner"></div>
        </div>
      )}
    </div>
  );
};

export default DocumentEditor;